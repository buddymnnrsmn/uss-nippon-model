#!/usr/bin/env python3
"""
Integrate Bloomberg Data with Monte Carlo Engine
=================================================

This script takes calibrated Bloomberg data and updates the
Monte Carlo simulation parameters in the main model.

Usage:
    python integrate_with_model.py

Author: RAMBAS Financial Model Team
"""

import sys
from pathlib import Path

# Add parent directory for imports
sys.path.append(str(Path(__file__).parent.parent))

import pandas as pd
import numpy as np
from typing import Dict

from bloomberg_loader import BloombergDataLoader, CACHE_DIR, RAW_DIR


def load_calibration_data() -> Dict:
    """Load previously calibrated data from cache."""

    # Check for cached statistics
    stats_path = RAW_DIR / 'statistics.csv'
    corr_path = RAW_DIR / 'correlations.csv'

    if not stats_path.exists():
        print("No calibration data found. Run bloomberg_loader.py --load-all --save first.")
        return {}

    stats_df = pd.read_csv(stats_path)

    correlations = None
    if corr_path.exists():
        correlations = pd.read_csv(corr_path, index_col=0)

    return {
        'statistics': stats_df,
        'correlations': correlations,
    }


def generate_monte_carlo_config(stats_df: pd.DataFrame,
                                correlations: pd.DataFrame = None) -> str:
    """
    Generate Python code for Monte Carlo configuration.

    Returns:
        String containing Python code to paste into monte_carlo_engine.py
    """
    lines = []
    lines.append("# =============================================================================")
    lines.append("# CALIBRATED PARAMETERS FROM BLOOMBERG DATA")
    lines.append("# =============================================================================")
    lines.append("# Auto-generated by integrate_with_model.py")
    lines.append(f"# Generated: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M')}")
    lines.append("")
    lines.append("CALIBRATED_DISTRIBUTIONS = {")

    # Steel prices
    steel_rows = stats_df[stats_df['name'].str.contains('hrc|crc|hdg|octg|scrap', case=False, na=False)]

    for _, row in steel_rows.iterrows():
        name = row['name']
        vol = row['annualized_volatility']

        # Convert to price factor format
        factor_name = f"{name}_price_factor"

        # Default to 0.18 if volatility is missing
        if pd.isna(vol) or vol == 0:
            vol = 0.18

        lines.append(f"    '{factor_name}': {{")
        lines.append(f"        'dist_type': 'lognormal',")
        lines.append(f"        'params': {{")
        lines.append(f"            'mean': np.log(0.95),  # Base case factor")
        lines.append(f"            'std': {vol:.4f},  # Calibrated volatility")
        lines.append(f"        }},")
        lines.append(f"        'historical_mean': {row['mean']:.2f},")
        lines.append(f"        'historical_std': {row['std']:.2f},")
        lines.append(f"    }},")

    lines.append("}")
    lines.append("")

    # Correlation matrix
    if correlations is not None and not correlations.empty:
        lines.append("CALIBRATED_CORRELATIONS = {")

        # Extract key correlations
        for i, col1 in enumerate(correlations.columns):
            for col2 in correlations.columns[i+1:]:
                corr_val = correlations.loc[col1, col2]
                if not pd.isna(corr_val) and abs(corr_val) > 0.3:  # Only significant correlations
                    lines.append(f"    ('{col1}', '{col2}'): {corr_val:.3f},")

        lines.append("}")

    return "\n".join(lines)


def update_monte_carlo_engine(config_code: str, dry_run: bool = True):
    """
    Update the monte_carlo_engine.py with calibrated parameters.

    Args:
        config_code: Python code to insert
        dry_run: If True, just print what would be changed
    """
    engine_path = Path(__file__).parent.parent / 'sensitivity_analysis' / 'monte_carlo_engine.py'

    if not engine_path.exists():
        print(f"Monte Carlo engine not found at: {engine_path}")
        return

    print("\n" + "=" * 60)
    print("INTEGRATION WITH MONTE CARLO ENGINE")
    print("=" * 60)

    if dry_run:
        print("\n[DRY RUN] Would add the following to monte_carlo_engine.py:\n")
        print(config_code)
        print("\n" + "-" * 60)
        print("To apply changes, run with --apply flag")
    else:
        # Read existing file
        with open(engine_path, 'r') as f:
            content = f.read()

        # Find insertion point (after imports, before class definition)
        insertion_marker = "# CALIBRATED PARAMETERS FROM BLOOMBERG DATA"

        if insertion_marker in content:
            # Replace existing calibration section
            start = content.find(insertion_marker)
            # Find the end of the section (next class or function definition)
            end = content.find("\nclass ", start)
            if end == -1:
                end = content.find("\ndef ", start)

            if end != -1:
                content = content[:start] + config_code + "\n\n" + content[end:]
        else:
            # Insert before first class definition
            class_pos = content.find("\nclass ")
            if class_pos != -1:
                content = content[:class_pos] + "\n\n" + config_code + "\n" + content[class_pos:]

        # Write updated file
        with open(engine_path, 'w') as f:
            f.write(content)

        print(f"âœ“ Updated {engine_path}")


def create_scenario_mapping(stats_df: pd.DataFrame) -> str:
    """
    Create scenario price factor mapping based on historical percentiles.
    """
    lines = []
    lines.append("# =============================================================================")
    lines.append("# SCENARIO PRICE FACTORS (Based on Historical Percentiles)")
    lines.append("# =============================================================================")
    lines.append("")
    lines.append("SCENARIO_PRICE_FACTORS = {")

    # Get HRC statistics
    hrc_row = stats_df[stats_df['name'].str.contains('hrc_us', case=False, na=False)]

    if not hrc_row.empty:
        row = hrc_row.iloc[0]
        mean = row['mean']
        q1 = row['q1']
        median = row['median']
        q3 = row['q3']
        min_val = row['min']
        max_val = row['max']

        # Define scenarios based on percentiles
        lines.append(f"    # Based on HRC historical range: ${min_val:.0f} - ${max_val:.0f}")
        lines.append(f"    # Median: ${median:.0f}, Mean: ${mean:.0f}")
        lines.append(f"    'severe_downturn': {min_val / mean:.2f},  # Historical minimum")
        lines.append(f"    'downside': {q1 / mean:.2f},  # 25th percentile")
        lines.append(f"    'base_case': {median / mean:.2f},  # 50th percentile (median)")
        lines.append(f"    'above_average': {q3 / mean:.2f},  # 75th percentile")
        lines.append(f"    'optimistic': {max_val / mean:.2f},  # Historical maximum")

    lines.append("}")

    return "\n".join(lines)


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Integrate Bloomberg data with model')
    parser.add_argument('--apply', action='store_true',
                        help='Apply changes to monte_carlo_engine.py')
    parser.add_argument('--show-scenarios', action='store_true',
                        help='Show scenario price factor mapping')

    args = parser.parse_args()

    # Load calibration data
    data = load_calibration_data()

    if not data:
        return 1

    stats_df = data['statistics']
    correlations = data.get('correlations')

    print("\n" + "=" * 60)
    print("BLOOMBERG DATA INTEGRATION")
    print("=" * 60)
    print(f"Loaded {len(stats_df)} series statistics")
    if correlations is not None:
        print(f"Loaded {len(correlations)}x{len(correlations)} correlation matrix")

    # Generate configuration code
    config_code = generate_monte_carlo_config(stats_df, correlations)

    # Update monte carlo engine
    update_monte_carlo_engine(config_code, dry_run=not args.apply)

    # Show scenario mapping
    if args.show_scenarios:
        print("\n")
        print(create_scenario_mapping(stats_df))

    return 0


if __name__ == '__main__':
    sys.exit(main())
